def merge(*args):
    """
    Generator merge(…) which accepts as arguments an arbitrary number of iterables,
    each of which generates sorted numbers, not necessarily one after another.
    merge() must merge the outputs of the iterables, i.e. give sorted queue of all
    the numbers from the input iterables. merge() must correctly stop if all
    of the input iterables have stopped. Please supply unit tests for your solution.

    E.g., the input iterables are three generators giving the following numbers:

    Iterable 1: 1, 5, 9
    Iterable 2: 2, 5
    Iterable 3: 1, 6, 10, 11

    The sequence generated by merge(…) in this case must be: 1, 1, 2, 5, 5, 6, 9, 10,

    :param args: input any iterables objects or array
    :return: generator-object
    """
    # Created array with iterable objects, if args are 'list' or 'tuple' array, we convert them
    iter_convert_input_args = [i.__iter__() if type(i) in (tuple, list) else i for i in args]
    # Create a dictionary where key is iter object, value is None "{<iter obj>: None, ...} "
    iterators_dict = {obj: None for obj in iter_convert_input_args}
    # Each step 'while' cycle we get first value on each input generator,
    # and add this value in 'iterators_dict'
    while True:

        for sequence in iter_convert_input_args:
            # If generators has not value and he is not ended, we set value
            if iterators_dict[sequence] is None and iterators_dict[sequence] != 'done':
                try:
                    iterators_dict[sequence] = next(sequence)
                except StopIteration:
                    # When generators will be end, we set 'done' for them
                    iterators_dict[sequence] = 'done'

        min_values_list = list(iterators_dict.values())
        # If all generators will be ended, we break cycle
        if min_values_list.count('done') == len(min_values_list):
            return
        # turn over our dictionary so that later we can set None for generators with min value
        reverse_iter_dict = dict(zip(min_values_list, iterators_dict.keys()))
        min_value = min(filter(lambda x: x != 'done', min_values_list))
        iterators_dict[reverse_iter_dict[min_value]] = None
        yield min_value
